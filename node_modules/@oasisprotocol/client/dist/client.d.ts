import * as grpcWeb from 'grpc-web';
import * as types from './types';
export declare class GRPCWrapper {
    client: grpcWeb.AbstractClientBase;
    base: string;
    constructor(base: string);
    protected callUnary<REQ, RESP>(desc: grpcWeb.MethodDescriptor<REQ, RESP>, request: REQ): Promise<RESP>;
    protected callServerStreaming<REQ, RESP>(desc: grpcWeb.MethodDescriptor<REQ, RESP>, request: REQ): grpcWeb.ClientReadableStream<RESP>;
}
export declare class NodeInternal extends GRPCWrapper {
    constructor(base: string);
    /**
     * GetBaseEpoch returns the base epoch.
     */
    beaconGetBaseEpoch(): Promise<number | bigint>;
    /**
     * GetEpoch returns the epoch number at the specified block height.
     * Calling this method with height `consensus.HeightLatest`, should
     * return the epoch of latest known block.
     */
    beaconGetEpoch(height: types.longnum): Promise<number | bigint>;
    /**
     * GetFutureEpoch returns any future epoch that is currently scheduled
     * to occur at a specific height.
     *
     * Note that this may return a nil state in case no future epoch is
     * currently scheduled.
     */
    beaconGetFutureEpoch(height: types.longnum): Promise<types.BeaconEpochTimeState>;
    /**
     * WaitEpoch waits for a specific epoch.
     *
     * Note that an epoch is considered reached even if any epoch greater
     * than the one specified is reached (e.g., that the current epoch
     * is already in the future).
     */
    beaconWaitEpoch(epoch: types.longnum): Promise<void>;
    /**
     * GetEpochBlock returns the block height at the start of the said
     * epoch.
     */
    beaconGetEpochBlock(epoch: types.longnum): Promise<number | bigint>;
    /**
     * GetBeacon gets the beacon for the provided block height.
     * Calling this method with height `consensus.HeightLatest` should
     * return the beacon for the latest finalized block.
     */
    beaconGetBeacon(height: types.longnum): Promise<Uint8Array>;
    /**
     * StateToGenesis returns the genesis state at specified block height.
     */
    beaconStateToGenesis(height: types.longnum): Promise<types.BeaconGenesis>;
    /**
     * ConsensusParameters returns the beacon consensus parameters.
     */
    beaconConsensusParameters(height: types.longnum): Promise<types.BeaconConsensusParameters>;
    /**
     * WatchEpochs returns a channel that produces a stream of messages
     * on epoch transitions.
     *
     * Upon subscription the current epoch is sent immediately.
     */
    beaconWatchEpochs(arg: void): grpcWeb.ClientReadableStream<number | bigint>;
    /**
     * GetValidators returns the vector of consensus validators for
     * a given epoch.
     */
    schedulerGetValidators(height: types.longnum): Promise<types.SchedulerValidator[]>;
    /**
     * GetCommittees returns the vector of committees for a given
     * runtime ID, at the specified block height, and optional callback
     * for querying the beacon for a given epoch/block height.
     *
     * Iff the callback is nil, `beacon.GetBlockBeacon` will be used.
     */
    schedulerGetCommittees(request: types.SchedulerGetCommitteesRequest): Promise<types.SchedulerCommittee[]>;
    /**
     * StateToGenesis returns the genesis state at specified block height.
     */
    schedulerStateToGenesis(height: types.longnum): Promise<types.SchedulerGenesis>;
    /**
     * ConsensusParameters returns the scheduler consensus parameters.
     */
    schedulerConsensusParameters(height: types.longnum): Promise<types.SchedulerConsensusParameters>;
    /**
     * WatchCommittees returns a channel that produces a stream of
     * Committee.
     *
     * Upon subscription, all committees for the current epoch will
     * be sent immediately.
     */
    schedulerWatchCommittees(): grpcWeb.ClientReadableStream<types.SchedulerCommittee>;
    /**
     * GetEntity gets an entity by ID.
     */
    registryGetEntity(query: types.RegistryIDQuery): Promise<types.Entity>;
    /**
     * GetEntities gets a list of all registered entities.
     */
    registryGetEntities(height: types.longnum): Promise<types.Entity[]>;
    /**
     * GetNode gets a node by ID.
     */
    registryGetNode(query: types.RegistryIDQuery): Promise<types.Node>;
    /**
     * GetNodeByConsensusAddress looks up a node by its consensus address at the
     * specified block height. The nature and format of the consensus address depends
     * on the specific consensus backend implementation used.
     */
    registryGetNodeByConsensusAddress(query: types.RegistryConsensusAddressQuery): Promise<types.Node>;
    /**
     * GetNodeStatus returns a node's status.
     */
    registryGetNodeStatus(query: types.RegistryIDQuery): Promise<types.Node>;
    /**
     * GetNodes gets a list of all registered nodes.
     */
    registryGetNodes(height: types.longnum): Promise<types.Node[]>;
    /**
     * GetRuntime gets a runtime by ID.
     */
    registryGetRuntime(query: types.RegistryNamespaceQuery): Promise<types.RegistryRuntime>;
    /**
     * GetRuntimes returns the registered Runtimes at the specified
     * block height.
     */
    registryGetRuntimes(query: types.RegistryGetRuntimesQuery): Promise<types.RegistryRuntime[]>;
    /**
     * StateToGenesis returns the genesis state at specified block height.
     */
    registryStateToGenesis(height: types.longnum): Promise<types.RegistryGenesis>;
    /**
     * GetEvents returns the events at specified block height.
     */
    registryGetEvents(height: types.longnum): Promise<types.RegistryEvent[]>;
    /**
     * WatchEntities returns a channel that produces a stream of
     * EntityEvent on entity registration changes.
     */
    registryWatchEntities(): grpcWeb.ClientReadableStream<types.RegistryEntityEvent>;
    /**
     * WatchNodes returns a channel that produces a stream of
     * NodeEvent on node registration changes.
     */
    registryWatchNodes(): grpcWeb.ClientReadableStream<types.RegistryNodeEvent>;
    /**
     * WatchNodeList returns a channel that produces a stream of NodeList.
     * Upon subscription, the node list for the current epoch will be sent
     * immediately.
     *
     * Each node list will be sorted by node ID in lexicographically ascending
     * order.
     */
    registryWatchNodeList(): grpcWeb.ClientReadableStream<types.RegistryNodeList>;
    /**
     * WatchRuntimes returns a stream of Runtime.  Upon subscription,
     * all runtimes will be sent immediately.
     */
    registryWatchRuntimes(): grpcWeb.ClientReadableStream<types.RegistryRuntime>;
    /**
     * TokenSymbol returns the token's ticker symbol.
     */
    stakingTokenSymbol(): Promise<string>;
    /**
     * TokenValueExponent is the token's value base-10 exponent, i.e.
     * 1 token = 10**TokenValueExponent base units.
     */
    stakingTokenValueExponent(): Promise<number>;
    /**
     * TotalSupply returns the total number of base units.
     */
    stakingTotalSupply(height: types.longnum): Promise<Uint8Array>;
    /**
     * CommonPool returns the common pool balance.
     */
    stakingCommonPool(height: types.longnum): Promise<Uint8Array>;
    /**
     * LastBlockFees returns the collected fees for previous block.
     */
    stakingLastBlockFees(height: types.longnum): Promise<Uint8Array>;
    /**
     * GovernanceDeposits returns the governance deposits account balance.
     */
    stakingGovernanceDeposits(height: types.longnum): Promise<Uint8Array>;
    /**
     * Threshold returns the specific staking threshold by kind.
     */
    stakingThreshold(query: types.StakingThresholdQuery): Promise<Uint8Array>;
    /**
     * Addresses returns the addresses of all accounts with a non-zero general
     * or escrow balance.
     */
    stakingAddresses(height: types.longnum): Promise<Uint8Array[]>;
    /**
     * Account returns the account descriptor for the given account.
     */
    stakingAccount(query: types.StakingOwnerQuery): Promise<types.StakingAccount>;
    /**
     * DelegationsFor returns the list of (outgoing) delegations for the given
     * owner (delegator).
     */
    stakingDelegationsFor(query: types.StakingOwnerQuery): Promise<Map<Uint8Array, types.StakingDelegation>>;
    /**
     * DelegationsInfosFor returns (outgoing) delegations with additional
     * information for the given owner (delegator).
     */
    stakingDelegationInfosFor(query: types.StakingOwnerQuery): Promise<Map<Uint8Array, types.StakingDelegationInfo>>;
    /**
     * DelegationsTo returns the list of (incoming) delegations to the given
     * account.
     */
    stakingDelegationsTo(query: types.StakingOwnerQuery): Promise<Map<Uint8Array, types.StakingDelegation>>;
    /**
     * DebondingDelegationsFor returns the list of (outgoing) debonding
     * delegations for the given owner (delegator).
     */
    stakingDebondingDelegationsFor(query: types.StakingOwnerQuery): Promise<Map<Uint8Array, types.StakingDebondingDelegation[]>>;
    /**
     * DebondingDelegationsInfosFor returns (outgoing) debonding delegations
     * with additional information for the given owner (delegator).
     */
    stakingDebondingDelegationInfosFor(query: types.StakingOwnerQuery): Promise<Map<Uint8Array, types.StakingDebondingDelegationInfo[]>>;
    /**
     * DebondingDelegationsTo returns the list of (incoming) debonding
     * delegations to the given account.
     */
    stakingDebondingDelegationsTo(query: types.StakingOwnerQuery): Promise<Map<Uint8Array, types.StakingDebondingDelegation[]>>;
    /**
     * Allowance looks up the allowance for the given owner/beneficiary combination.
     */
    stakingAllowance(query: types.StakingAllowanceQuery): Promise<Uint8Array>;
    /**
     * StateToGenesis returns the genesis state at specified block height.
     */
    stakingStateToGenesis(height: types.longnum): Promise<types.StakingGenesis>;
    /**
     * Paremeters returns the staking consensus parameters.
     */
    stakingConsensusParameters(height: types.longnum): Promise<types.StakingConsensusParameters>;
    /**
     * GetEvents returns the events at specified block height.
     */
    stakingGetEvents(height: types.longnum): Promise<types.StakingEvent[]>;
    /**
     * WatchEvents returns a channel that produces a stream of Events.
     */
    stakingWatchEvents(): grpcWeb.ClientReadableStream<types.StakingEvent>;
    /**
     * GetStatus returns a key manager status by key manager ID.
     */
    keyManagerGetStatus(query: types.RegistryNamespaceQuery): Promise<types.KeyManagerStatus>;
    /**
     * GetStatuses returns all currently tracked key manager statuses.
     */
    keyManagerGetStatuses(height: types.longnum): Promise<types.KeyManagerStatus[]>;
    /**
     * ActiveProposals returns a list of all proposals that have not yet closed.
     */
    governanceActiveProposals(height: types.longnum): Promise<types.GovernanceProposal[]>;
    /**
     * Proposals returns a list of all proposals.
     */
    governanceProposals(height: types.longnum): Promise<types.GovernanceProposal[]>;
    /**
     * Proposal looks up a specific proposal.
     */
    governanceProposal(request: types.GovernanceProposalQuery): Promise<types.GovernanceProposal>;
    /**
     * Votes looks up votes for a specific proposal.
     */
    governanceVotes(request: types.GovernanceProposalQuery): Promise<types.GovernanceVoteEntry[]>;
    /**
     * PendingUpgrades returns a list of all pending upgrades.
     */
    governancePendingUpgrades(height: types.longnum): Promise<types.UpgradeDescriptor[]>;
    /**
     * StateToGenesis returns the genesis state at specified block height.
     */
    governanceStateToGenesis(height: types.longnum): Promise<types.GovernanceGenesis>;
    /**
     * ConsensusParameters returns the governance consensus parameters.
     */
    governanceConsensusParameters(height: types.longnum): Promise<types.GovernanceConsensusParameters>;
    /**
     * GetEvents returns the events at specified block height.
     */
    governanceGetEvents(height: types.longnum): Promise<types.GovernanceEvent[]>;
    /**
     * WatchEvents returns a channel that produces a stream of Events.
     */
    governanceWatchEvents(): grpcWeb.ClientReadableStream<types.GovernanceEvent>;
    /**
     * SyncGet fetches a single key and returns the corresponding proof.
     */
    storageSyncGet(request: types.StorageGetRequest): Promise<types.StorageProofResponse>;
    /**
     * SyncGetPrefixes fetches all keys under the given prefixes and returns
     * the corresponding proofs.
     */
    storageSyncGetPrefixes(request: types.StorageGetPrefixesRequest): Promise<types.StorageProofResponse>;
    /**
     * SyncIterate seeks to a given key and then fetches the specified
     * number of following items based on key iteration order.
     */
    storageSyncIterate(request: types.StorageIterateRequest): Promise<types.StorageProofResponse>;
    /**
     * Apply applies a set of operations against the MKVS.  The root may refer
     * to a nil node, in which case a new root will be created.
     * The expected new root is used to check if the new root after all the
     * operations are applied already exists in the local DB.  If it does, the
     * Apply is ignored.
     */
    storageApply(request: types.StorageApplyRequest): Promise<types.SignatureSigned[]>;
    /**
     * ApplyBatch applies multiple sets of operations against the MKVS and
     * returns a single receipt covering all applied roots.
     *
     * See Apply for more details.
     */
    storageApplyBatch(request: types.StorageApplyBatchRequest): Promise<types.SignatureSigned[]>;
    /**
     * GetCheckpoints returns a list of checkpoint metadata for all known checkpoints.
     */
    storageGetCheckpoints(request: types.StorageGetCheckpointsRequest): Promise<types.StorageMetadata[]>;
    /**
     * GetDiff returns an iterator of write log entries that must be applied
     * to get from the first given root to the second one.
     */
    storageGetDiff(request: types.StorageGetDiffRequest): grpcWeb.ClientReadableStream<types.StorageSyncChunk>;
    /**
     * GetCheckpointChunk fetches a specific chunk from an existing chekpoint.
     */
    storageGetCheckpointChunk(chunk: types.StorageChunkMetadata): grpcWeb.ClientReadableStream<Uint8Array>;
    /**
     * GetLastSyncedRound retrieves the last synced round for the storage worker.
     */
    storageWorkerGetLastSyncedRound(request: types.WorkerStorageGetLastSyncedRoundRequest): Promise<types.WorkerStorageGetLastSyncedRoundResponse>;
    /**
     * ForceFinalize forces finalization of a specific round.
     */
    storageWorkerForceFinalize(request: types.WorkerStorageForceFinalizeRequest): Promise<void>;
    /**
     * SubmitTx submits a transaction to the runtime transaction scheduler and waits
     * for transaction execution results.
     */
    runtimeClientSubmitTx(request: types.RuntimeClientSubmitTxRequest): Promise<Uint8Array>;
    /**
     * SubmitTxNoWait submits a transaction to the runtime transaction scheduler but does
     * not wait for transaction execution.
     */
    runtimeClientSubmitTxNoWait(request: types.RuntimeClientSubmitTxRequest): Promise<Uint8Array>;
    /**
     * CheckTx asks the local runtime to check the specified transaction.
     */
    runtimeClientCheckTx(request: types.RuntimeClientCheckTxRequest): Promise<void>;
    /**
     * GetGenesisBlock returns the genesis block.
     */
    runtimeClientGetGenesisBlock(runtimeID: Uint8Array): Promise<types.RoothashBlock>;
    /**
     * GetBlock fetches the given runtime block.
     */
    runtimeClientGetBlock(request: types.RuntimeClientGetBlockRequest): Promise<types.RoothashBlock>;
    /**
     * GetBlockByHash fetches the given runtime block by its block hash.
     */
    runtimeClientGetBlockByHash(request: types.RuntimeClientGetTxByBlockHashRequest): Promise<types.RoothashBlock>;
    /**
     * GetTx fetches the given runtime transaction.
     */
    runtimeClientGetTx(request: types.RuntimeClientGetTxRequest): Promise<types.RuntimeClientTxResult>;
    /**
     * GetTxByBlockHash fetches the given rutnime transaction where the
     * block is identified by its hash instead of its round number.
     */
    runtimeClientGetTxByBlockHash(request: types.RuntimeClientGetTxByBlockHashRequest): Promise<types.RuntimeClientTxResult>;
    /**
     * GetTxs fetches all runtime transactions in a given block.
     */
    runtimeClientGetTxs(request: types.RuntimeClientGetTxsRequest): Promise<Uint8Array[]>;
    /**
     * GetEvents returns all events emitted in a given block.
     */
    runtimeClientGetEvents(request: types.RuntimeClientGetEventsRequest): Promise<types.RuntimeClientEvent[]>;
    /**
     * Query makes a runtime-specific query.
     */
    runtimeClientQuery(request: types.RuntimeClientQueryRequest): Promise<types.RuntimeClientQueryResponse>;
    /**
     * QueryTx queries the indexer for a specific runtime transaction.
     */
    runtimeClientQueryTx(request: types.RuntimeClientQueryTxRequest): Promise<types.RuntimeClientTxResult>;
    /**
     * QueryTxs queries the indexer for specific runtime transactions.
     */
    runtimeClientQueryTxs(request: types.RuntimeClientQueryTxsRequest): Promise<types.RuntimeClientTxResult[]>;
    /**
     * WaitBlockIndexed waits for a runtime block to be indexed by the indexer.
     */
    runtimeClientWaitBlockIndexed(request: types.RuntimeClientWaitBlockIndexedRequest): Promise<void>;
    /**
     * WatchBlocks subscribes to blocks for a specific runtimes.
     */
    runtimeClientWatchBlocks(runtimeID: Uint8Array): grpcWeb.ClientReadableStream<types.RoothashAnnotatedBlock>;
    /**
     * CallEnclave sends the request bytes to the target enclave.
     */
    enclaveRPCCallEnclave(request: types.EnclaveRPCCallEnclaveRequest): Promise<Uint8Array>;
    /**
     * SubmitTx submits a signed consensus transaction and waits for the transaction to be included
     * in a block. Use SubmitTxNoWait if you only need to broadcast the transaction.
     */
    consensusSubmitTx(tx: types.SignatureSigned): Promise<void>;
    /**
     * StateToGenesis returns the genesis state at the specified block height.
     */
    consensusStateToGenesis(height: types.longnum): Promise<types.GenesisDocument>;
    /**
     * EstimateGas calculates the amount of gas required to execute the given transaction.
     */
    consensusEstimateGas(req: types.ConsensusEstimateGasRequest): Promise<number | bigint>;
    /**
     * GetSignerNonce returns the nonce that should be used by the given
     * signer for transmitting the next transaction.
     */
    consensusGetSignerNonce(req: types.ConsensusGetSignerNonceRequest): Promise<number | bigint>;
    /**
     * GetBlock returns a consensus block at a specific height.
     */
    consensusGetBlock(height: types.longnum): Promise<types.ConsensusBlock>;
    /**
     * GetTransactions returns a list of all transactions contained within a
     * consensus block at a specific height.
     *
     * NOTE: Any of these transactions could be invalid.
     */
    consensusGetTransactions(height: types.longnum): Promise<Uint8Array[]>;
    /**
     * GetTransactionsWithResults returns a list of transactions and their
     * execution results, contained within a consensus block at a specific
     * height.
     */
    consensusGetTransactionsWithResults(height: types.longnum): Promise<types.ConsensusTransactionsWithResults>;
    /**
     * GetUnconfirmedTransactions returns a list of transactions currently in the local node's
     * mempool. These have not yet been included in a block.
     */
    consensusGetUnconfirmedTransactions(): Promise<Uint8Array[]>;
    /**
     * GetGenesisDocument returns the original genesis document.
     */
    consensusGetGenesisDocument(): Promise<types.GenesisDocument>;
    /**
     * GetChainContext returns the chain domain separation context.
     */
    consensusGetChainContext(): Promise<string>;
    /**
     * GetStatus returns the current status overview.
     */
    consensusGetStatus(): Promise<types.ConsensusStatus>;
    /**
     * WatchBlocks returns a channel that produces a stream of consensus
     * blocks as they are being finalized.
     */
    consensusWatchBlocks(): grpcWeb.ClientReadableStream<types.ConsensusBlock>;
    /**
     * GetLightBlock returns a light version of the consensus layer block that can be used for light
     * client verification.
     */
    consensusLightGetLightBlock(height: types.longnum): Promise<types.ConsensusLightBlock>;
    /**
     * GetParameters returns the consensus parameters for a specific height.
     */
    consensusLightGetParameters(height: types.longnum): Promise<types.ConsensusLightParameters>;
    /**
     * SyncGet fetches a single key and returns the corresponding proof.
     */
    consensusLightStateSyncGet(request: types.StorageGetRequest): Promise<types.StorageProofResponse>;
    /**
     * SyncGetPrefixes fetches all keys under the given prefixes and returns
     * the corresponding proofs.
     */
    consensusLightStateSyncGetPrefixes(request: types.StorageGetPrefixesRequest): Promise<types.StorageProofResponse>;
    /**
     * SyncIterate seeks to a given key and then fetches the specified
     * number of following items based on key iteration order.
     */
    consensusLightStateSyncIterate(request: types.StorageIterateRequest): Promise<types.StorageProofResponse>;
    /**
     * SubmitTxNoWait submits a signed consensus transaction, but does not wait for the transaction
     * to be included in a block. Use SubmitTx if you need to wait for execution.
     */
    consensusLightSubmitTxNoWait(tx: types.SignatureSigned): Promise<void>;
    /**
     * SubmitEvidence submits evidence of misbehavior.
     */
    consensusLightSubmitEvidence(evidence: types.ConsensusEvidence): Promise<void>;
    /**
     * RequestShutdown requests the node to shut down gracefully.
     *
     * If the wait argument is true then the method will also wait for the
     * shutdown to complete.
     */
    nodeControllerRequestShudown(): Promise<void>;
    /**
     * WaitSync waits for the node to finish syncing.
     */
    nodeControllerWaitSync(): Promise<void>;
    /**
     * IsSynced checks whether the node has finished syncing.
     */
    nodeControllerIsSynced(): Promise<boolean>;
    /**
     * WaitReady waits for the node to accept runtime work.
     */
    nodeControllerWaitReady(): Promise<void>;
    /**
     * IsReady checks whether the node is ready to accept runtime work.
     */
    nodeControllerIsReady(): Promise<boolean>;
    /**
     * UpgradeBinary submits an upgrade descriptor to a running node.
     * The node will wait for the appropriate epoch, then update its binaries
     * and shut down.
     */
    nodeControllerUpgradeBinary(descriptor: types.UpgradeDescriptor): Promise<void>;
    /**
     * CancelUpgrade cancels the specific pending upgrade, unless it is already in progress.
     */
    nodeControllerCancelUpgrade(descriptor: types.UpgradeDescriptor): Promise<void>;
    /**
     * GetStatus returns the current status overview of the node.
     */
    nodeControllerGetStatus(): Promise<types.ControlStatus>;
    /**
     * SetEpoch manually sets the current epoch to the given epoch.
     *
     * NOTE: This only works with a mock beacon backend and will otherwise
     *       return an error.
     */
    debugControllerSetEpoch(epoch: types.longnum): Promise<void>;
    /**
     * WaitNodesRegistered waits for the given number of nodes to register.
     */
    debugControllerWaitNodesRegistered(count: number): Promise<void>;
}
