"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.openExecutorCommitment = exports.ERR_BAD_PROPOSER_COMMITMENT_CODE = exports.ERR_NO_PROPOSER_COMMITMENT_CODE = exports.ERR_INVALID_ROUND_CODE = exports.ERR_MAJORITY_FAILURE_CODE = exports.ERR_NODE_IS_SCHEDULER_CODE = exports.ERR_TIMEOUT_NOT_CORRECT_ROUND_CODE = exports.ERR_BAD_STORAGE_RECEIPTS_CODE = exports.ERR_INVALID_MESSAGES_CODE = exports.ERR_TXN_SCHED_SIG_INVALID_CODE = exports.ERR_BAD_EXECUTOR_COMMITMENT_CODE = exports.ERR_INSUFFICIENT_VOTES_CODE = exports.ERR_STILL_WAITING_CODE = exports.ERR_DISCREPANCY_DETECTED_CODE = exports.ERR_NOT_BASED_ON_CORRECT_BLOCK_CODE = exports.ERR_ALREADY_COMMITTED_CODE = exports.ERR_NOT_IN_COMMITTEE_CODE = exports.ERR_RAK_SIG_INVALID_CODE = exports.ERR_INVALID_COMMITTEE_KIND_CODE = exports.ERR_NO_COMMITTEE_CODE = exports.ERR_NO_RUNTIME_CODE = exports.COMMITMENT_MODULE_NAME = exports.ERR_INVALID_EVIDENCE_CODE = exports.ERR_DUPLICATE_EVIDENCE_CODE = exports.ERR_RUNTIME_DOES_NOT_SLASH_CODE = exports.ERR_MAX_MESSAGES_TOO_BIG_CODE = exports.ERR_PROPOSER_TIMEOUT_NOT_ALLOWED_CODE = exports.ERR_RUNTIME_SUSPENDED_CODE = exports.ERR_NO_EXECUTOR_POOL_CODE = exports.ERR_INVALID_RUNTIME_CODE = exports.ERR_NOT_FOUND_CODE = exports.ERR_INVALID_ARGUMENT_CODE = exports.MODULE_NAME = exports.FAILURE_STORAGE_UNAVAILABLE = exports.FAILURE_UNKNOWN = exports.FAILURE_NONE = exports.SUSPENDED = exports.EPOCH_TRANSITION = exports.ROUND_FAILED = exports.NORMAL = exports.INVALID = exports.GAS_OP_EVIDENCE = exports.GAS_OP_PROPOSER_TIMEOUT = exports.GAS_OP_COMPUTE_COMMIT = exports.METHOD_EVIDENCE = exports.METHOD_EXECUTOR_PROPOSER_TIMEOUT = exports.METHOD_EXECUTOR_COMMIT = exports.PROPOSED_BATCH_SIGNATURE_CONTEXT = exports.COMPUTE_RESULTS_HEADER_SIGNATURE_CONTEXT = exports.EXECUTOR_SIGNATURE_CONTEXT = void 0;
exports.evidenceWrapper = exports.executorProposerTimeoutWrapper = exports.executorCommitWrapper = exports.signProposedBatch = exports.openProposedBatch = exports.signComputeResultsHeader = exports.verifyComputeResultsHeader = exports.signExecutorCommitment = void 0;
const consensus = require("./consensus");
const misc = require("./misc");
const signature = require("./signature");
/**
 * ExecutorSignatureContext is the signature context used to sign executor
 * worker commitments.
 */
exports.EXECUTOR_SIGNATURE_CONTEXT = 'oasis-core/roothash: executor commitment';
/**
 * ComputeResultsHeaderSignatureContext is the signature context used to
 * sign compute results headers with RAK.
 */
exports.COMPUTE_RESULTS_HEADER_SIGNATURE_CONTEXT = 'oasis-core/roothash: compute results header';
/**
 * ProposedBatchSignatureContext is the context used for signing propose batch
 * dispatch messages.
 */
exports.PROPOSED_BATCH_SIGNATURE_CONTEXT = 'oasis-core/roothash: proposed batch';
/**
 * MethodExecutorCommit is the method name for executor commit submission.
 */
exports.METHOD_EXECUTOR_COMMIT = 'roothash.ExecutorCommit';
/**
 * MethodExecutorProposerTimeout is the method name for executor.
 */
exports.METHOD_EXECUTOR_PROPOSER_TIMEOUT = 'roothash.ExecutorProposerTimeout';
/**
 * MethodEvidence is the method name for submitting evidence of node misbehavior.
 */
exports.METHOD_EVIDENCE = 'roothash.Evidence';
/**
 * GasOpComputeCommit is the gas operation identifier for compute commits.
 */
exports.GAS_OP_COMPUTE_COMMIT = 'compute_commit';
/**
 * GasOpProposerTimeout is the gas operation identifier for executor propose timeout cost.
 */
exports.GAS_OP_PROPOSER_TIMEOUT = 'proposer_timeout';
/**
 * GasOpEvidence is the gas operation identifier for evidence submission transaction cost.
 */
exports.GAS_OP_EVIDENCE = 'evidence';
/**
 * Invalid is an invalid header type and should never be stored.
 */
exports.INVALID = 0;
/**
 * Normal is a normal header.
 */
exports.NORMAL = 1;
/**
 * RoundFailed is a header resulting from a failed round. Such a
 * header contains no transactions but advances the round as normal
 * to prevent replays of old commitments.
 */
exports.ROUND_FAILED = 2;
/**
 * EpochTransition is a header resulting from an epoch transition.
 *
 * Such a header contains no transactions but advances the round as
 * normal.
 * TODO: Consider renaming this to CommitteeTransition.
 */
exports.EPOCH_TRANSITION = 3;
/**
 * Suspended is a header resulting from the runtime being suspended.
 *
 * Such a header contains no transactions but advances the round as
 * normal.
 */
exports.SUSPENDED = 4;
/**
 * FailureNone indicates that no failure has occurred.
 */
exports.FAILURE_NONE = 0;
/**
 * FailureUnknown indicates a generic failure.
 */
exports.FAILURE_UNKNOWN = 1;
/**
 * FailureStorageUnavailable indicates that batch processing failed due to
 * storage being unavailable.
 */
exports.FAILURE_STORAGE_UNAVAILABLE = 2;
/**
 * ModuleName is a unique module name for the roothash module.
 */
exports.MODULE_NAME = 'roothash';
/**
 * ErrInvalidArgument is the error returned on malformed argument(s).
 */
exports.ERR_INVALID_ARGUMENT_CODE = 1;
/**
 * ErrNotFound is the error returned when a block is not found.
 */
exports.ERR_NOT_FOUND_CODE = 2;
/**
 * ErrInvalidRuntime is the error returned when the passed runtime is invalid.
 */
exports.ERR_INVALID_RUNTIME_CODE = 3;
/**
 * ErrNoExecutorPool is the error returned when there is no executor pool.
 */
exports.ERR_NO_EXECUTOR_POOL_CODE = 4;
/**
 * ErrRuntimeSuspended is the error returned when the passed runtime is suspended.
 */
exports.ERR_RUNTIME_SUSPENDED_CODE = 5;
/**
 * ErrProposerTimeoutNotAllowed is the error returned when proposer timeout is not allowed.
 */
exports.ERR_PROPOSER_TIMEOUT_NOT_ALLOWED_CODE = 6;
/**
 * ErrMaxMessagesTooBig is the error returned when the MaxMessages parameter is set to a value
 * larger than the MaxRuntimeMessages specified in consensus parameters.
 */
exports.ERR_MAX_MESSAGES_TOO_BIG_CODE = 7;
/**
 * ErrRuntimeDoesNotSlash is the error returned when misbehaviour evidence is submitted for a
 * runtime that does not slash.
 */
exports.ERR_RUNTIME_DOES_NOT_SLASH_CODE = 8;
/**
 * ErrDuplicateEvidence is the error returned when submitting already existing evidence.
 */
exports.ERR_DUPLICATE_EVIDENCE_CODE = 9;
/**
 * ErrInvalidEvidence is the error return when an invalid evidence is submitted.
 */
exports.ERR_INVALID_EVIDENCE_CODE = 10;
/**
 * moduleName is the module name used for namespacing errors.
 */
exports.COMMITMENT_MODULE_NAME = 'roothash/commitment';
exports.ERR_NO_RUNTIME_CODE = 1;
exports.ERR_NO_COMMITTEE_CODE = 2;
exports.ERR_INVALID_COMMITTEE_KIND_CODE = 3;
exports.ERR_RAK_SIG_INVALID_CODE = 4;
exports.ERR_NOT_IN_COMMITTEE_CODE = 5;
exports.ERR_ALREADY_COMMITTED_CODE = 6;
exports.ERR_NOT_BASED_ON_CORRECT_BLOCK_CODE = 7;
exports.ERR_DISCREPANCY_DETECTED_CODE = 8;
exports.ERR_STILL_WAITING_CODE = 9;
exports.ERR_INSUFFICIENT_VOTES_CODE = 10;
exports.ERR_BAD_EXECUTOR_COMMITMENT_CODE = 11;
exports.ERR_TXN_SCHED_SIG_INVALID_CODE = 12;
exports.ERR_INVALID_MESSAGES_CODE = 13;
exports.ERR_BAD_STORAGE_RECEIPTS_CODE = 14;
exports.ERR_TIMEOUT_NOT_CORRECT_ROUND_CODE = 15;
exports.ERR_NODE_IS_SCHEDULER_CODE = 16;
exports.ERR_MAJORITY_FAILURE_CODE = 17;
exports.ERR_INVALID_ROUND_CODE = 18;
exports.ERR_NO_PROPOSER_COMMITMENT_CODE = 19;
exports.ERR_BAD_PROPOSER_COMMITMENT_CODE = 20;
async function openExecutorCommitment(chainContext, runtimeID, signed) {
    const context = `${signature.combineChainContext(exports.EXECUTOR_SIGNATURE_CONTEXT, chainContext)} for runtime ${misc.toHex(runtimeID)}`;
    return misc.fromCBOR(await signature.openSigned(context, signed));
}
exports.openExecutorCommitment = openExecutorCommitment;
async function signExecutorCommitment(signer, chainContext, runtimeID, computeBody) {
    const context = `${signature.combineChainContext(exports.EXECUTOR_SIGNATURE_CONTEXT, chainContext)} for runtime ${misc.toHex(runtimeID)}`;
    return await signature.signSigned(signer, context, misc.toCBOR(computeBody));
}
exports.signExecutorCommitment = signExecutorCommitment;
async function verifyComputeResultsHeader(rakPub, header, rakSig) {
    return await signature.verify(rakPub, exports.COMPUTE_RESULTS_HEADER_SIGNATURE_CONTEXT, misc.toCBOR(header), rakSig);
}
exports.verifyComputeResultsHeader = verifyComputeResultsHeader;
async function signComputeResultsHeader(rakSigner, header) {
    return await rakSigner.sign(exports.COMPUTE_RESULTS_HEADER_SIGNATURE_CONTEXT, misc.toCBOR(header));
}
exports.signComputeResultsHeader = signComputeResultsHeader;
async function openProposedBatch(chainContext, runtimeID, signed) {
    const context = `${signature.combineChainContext(exports.PROPOSED_BATCH_SIGNATURE_CONTEXT, chainContext)} for runtime ${misc.toHex(runtimeID)}`;
    return misc.fromCBOR(await signature.openSigned(context, signed));
}
exports.openProposedBatch = openProposedBatch;
async function signProposedBatch(signer, chainContext, runtimeID, proposedBatch) {
    const context = `${signature.combineChainContext(exports.PROPOSED_BATCH_SIGNATURE_CONTEXT, chainContext)} for runtime ${misc.toHex(runtimeID)}`;
    return await signature.signSigned(signer, context, misc.toCBOR(proposedBatch));
}
exports.signProposedBatch = signProposedBatch;
function executorCommitWrapper() {
    return new consensus.TransactionWrapper(exports.METHOD_EXECUTOR_COMMIT);
}
exports.executorCommitWrapper = executorCommitWrapper;
function executorProposerTimeoutWrapper() {
    return new consensus.TransactionWrapper(exports.METHOD_EXECUTOR_PROPOSER_TIMEOUT);
}
exports.executorProposerTimeoutWrapper = executorProposerTimeoutWrapper;
function evidenceWrapper() {
    return new consensus.TransactionWrapper(exports.METHOD_EVIDENCE);
}
exports.evidenceWrapper = evidenceWrapper;
